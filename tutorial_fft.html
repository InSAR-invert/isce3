<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>ISCE: FFT Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ISCE
   &#160;<span id="projectnumber">3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="sphinx/html/index.html"><span>Python&#160;classes</span></a></li>
      <li><a href="https://github-fn.jpl.nasa.gov/isce-3/isce/issues/"><span>Issue&#160;Tracker</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">FFT Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#fftinclude">Include headers</a></li>
<li class="level1"><a href="#signalconstruct">Constructors</a><ul><li class="level2"><a href="#signalconstructsingle">single thread</a></li>
<li class="level2"><a href="#signalconstructmulti">Multi-threaded</a></li>
</ul>
</li>
<li class="level1"><a href="#forward">Forward FFT</a><ul><li class="level2"><a href="#forwardrange">Forward FFT in range direction (fast time)</a></li>
<li class="level2"><a href="#forwardazimuth">Forward FFT in azimuth direction (slow time)</a></li>
<li class="level2"><a href="#forward2d">Forward 2D FFT</a></li>
<li class="level2"><a href="#forwardfwd">Forward transformation</a></li>
</ul>
</li>
<li class="level1"><a href="#inverse">Inverse FFT</a><ul><li class="level2"><a href="#inverserange">Inverse FFT in range direction (fast time)</a></li>
<li class="level2"><a href="#inverseazimuth">Inverse FFT in azimuth direction (slow time)</a></li>
<li class="level2"><a href="#inverse2d">Inverse 2D FFT</a></li>
<li class="level2"><a href="#inverseinv">Inverse transformation</a></li>
</ul>
</li>
<li class="level1"><a href="#normalization">Un-normalized transformations</a></li>
<li class="level1"><a href="#nfft">Length of FFT</a></li>
<li class="level1"><a href="#upsample">Upsampling a signal in range direction</a></li>
<li class="level1"><a href="#example1">Example 1: forward and inverse FFT transformation in range direction</a></li>
</ul>
</div>
<div class="textblock"><p>A higher level interface to FFTW3 library is available in ISCE3 through isce::signal::Signal. This templated Signal class allows to compute 1D fft in range or azimuth direction or 2D fft. Signal supports both real and complex data and can be applied on block of data.</p>
<h1><a class="anchor" id="fftinclude"></a>
Include headers</h1>
<p>The following header file is required:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;isce/signal/Signal.h&quot;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="signalconstruct"></a>
Constructors</h1>
<p>Signal can be isntatiated for a multi-threaded FFT computation or for a signle thread computation.</p>
<h2><a class="anchor" id="signalconstructsingle"></a>
single thread</h2>
<p>For computing forward and inverse FFT with signle thread on real or complex float data, one can instatiate Signal as follows:</p>
<div class="fragment"><div class="line">isce::signal::Signal&lt;float&gt; sig;</div>
</div><!-- fragment --><p>Similarly for double precision real or complex data, one can instantiate an object of Signal as:</p>
<div class="fragment"><div class="line">isce::signal::Signal&lt;double&gt; sig;</div>
</div><!-- fragment --><h2><a class="anchor" id="signalconstructmulti"></a>
Multi-threaded</h2>
<p>For instantiating Signal to use the multi-threaded FFTW library, one can simply add the number of threads as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> numThreads = 8;</div>
<div class="line">isce::signal::Signal&lt;float&gt; sig(numThreads);</div>
</div><!-- fragment --><h1><a class="anchor" id="forward"></a>
Forward FFT</h1>
<p>For a forward transofrmation of a block of data, one needs to create the forward FFT plan which can be re-used many times for the actual transformation. To set up the FFT plans one need to have buffers defined for a block of data. For our applications we usually work on a two dimensional array of data. Given a block of data with number of lines of "length" and number of samples of "width" the required buffer can be defined as a std::valarray or as a raw pointer array:</p>
<div class="fragment"><div class="line"><span class="comment">// reserve memory for a block of data</span></div>
<div class="line">std::valarray&lt;std::complex&lt;float&gt;&gt; data(width*length);</div>
<div class="line"></div>
<div class="line"><span class="comment">// reserve memory for the spectrum of the block of data</span></div>
<div class="line">std::valarray&lt;std::complex&lt;float&gt;&gt; spectrum(width*length);</div>
</div><!-- fragment --><h2><a class="anchor" id="forwardrange"></a>
Forward FFT in range direction (fast time)</h2>
<p>Assuming the range (fast time) direction to be over the columns of an array, the forward FFT plan in range direction can be created as:</p>
<div class="fragment"><div class="line">sig.forwardRangeFFT(data, spectrum, width, length);</div>
</div><!-- fragment --><h2><a class="anchor" id="forwardazimuth"></a>
Forward FFT in azimuth direction (slow time)</h2>
<p>Assuming the azimuth (slow time) direction to be over the rows of an array, the forward FFT plan in azimuth direction can be created as:</p>
<div class="fragment"><div class="line">sig.forwardAzimuthFFT(data, spectrum, width, length);</div>
</div><!-- fragment --><h2><a class="anchor" id="forward2d"></a>
Forward 2D FFT</h2>
<p>Similarly to create forward 2D FFT plan one can call the</p>
<div class="fragment"><div class="line">sig.forward2DFFT(data, spectrum, width, length);</div>
</div><!-- fragment --><h2><a class="anchor" id="forwardfwd"></a>
Forward transformation</h2>
<p>Once the required FFT plan is created for 1D transform in range or azimuth direction or for 2D transform, then the actual transformation can be done by calling isce::signal::Signal::forward as:</p>
<div class="fragment"><div class="line">sig.forward(data, spectrum);</div>
</div><!-- fragment --><p>Note that regardless of the created plan (range, azimuth or 2D), the transformation is computed using the same function.</p>
<h1><a class="anchor" id="inverse"></a>
Inverse FFT</h1>
<p>Similar to Forward transformation, equivalent interfaces exist for inverse FFT transformation of a block of the spectrum.</p>
<h2><a class="anchor" id="inverserange"></a>
Inverse FFT in range direction (fast time)</h2>
<p>Assuming the range (fast time) direction to be over the columns of an array, the inverse FFT plan in range direction can be created as:</p>
<div class="fragment"><div class="line">sig.inverseRangeFFT(spectrum, data, width, length);</div>
</div><!-- fragment --><h2><a class="anchor" id="inverseazimuth"></a>
Inverse FFT in azimuth direction (slow time)</h2>
<p>The inverse FFT plan in azimuth direction can be created as:</p>
<div class="fragment"><div class="line">sig.inverseAzimuthFFT(spectrum, data, width, length);</div>
</div><!-- fragment --><h2><a class="anchor" id="inverse2d"></a>
Inverse 2D FFT</h2>
<p>Similarly, to create inverse 2D FFT plan, one can create an inverse FFT plan as follows:</p>
<div class="fragment"><div class="line">sig.inverse2DFFT(spectrum, data, width, length);</div>
</div><!-- fragment --><h2><a class="anchor" id="inverseinv"></a>
Inverse transformation</h2>
<p>Once the required FFT plan is created for 1D transformation in range or azimuth direction or for 2D transformation, then the actual transformation can be done by calling isce::signal::Signal::inverse as:</p>
<div class="fragment"><div class="line">sig.inverse(spectrum, data);</div>
</div><!-- fragment --><h1><a class="anchor" id="normalization"></a>
Un-normalized transformations</h1>
<p>Signal, follows FFTW3 convention and keeps the un-normalized FFT transformations as computed by FFTW3. This means that a forward FFT followed by an inverse FFT or vise versa results in the original signal scaled by length of fft. Depending on 1D transformation in range, azimuth or 2D transformation one may normalize the final results by dividing by length of FFT.</p>
<p>Assuming the data and spectrum blocks with a shape of (length x width) as introduced above, normalizing the results of forwrd and backward FFT computations in range, azimuth or 2D the final results should be divided by width, length or (widthxlength) respectively.</p>
<h1><a class="anchor" id="nfft"></a>
Length of FFT</h1>
<p>As described in FFTW3 documentation, FFTW is best at handling sizes of the form <img class="formulaInl" alt="$2^a$" src="form_78.png"/> <img class="formulaInl" alt="$3^b$" src="form_79.png"/> <img class="formulaInl" alt="$5^c$" src="form_80.png"/> <img class="formulaInl" alt="$7^d$" src="form_81.png"/> <img class="formulaInl" alt="$11^e$" src="form_82.png"/> <img class="formulaInl" alt="$13^f$" src="form_83.png"/>, where <img class="formulaInl" alt="$e+f$" src="form_84.png"/> is either 0 or 1, and the other exponents are arbitrary. Other sizes are computed by means of a slow algorithm. Transforms whose sizes are powers of 2 are especially fast. Therefore a user of Signal may use isce::signal::Signal::nextPowerOfTwo to compute the efficient length of signal and zero pad the signal accordingly before setting FFT plans.</p>
<h1><a class="anchor" id="upsample"></a>
Upsampling a signal in range direction</h1>
<p>Signal provides a function isce::signal::Signal::upsample to upsample a block of data in range direction by a given oversampling factor. After creating the forward range FFT plan based on the original signal and the inverse range FFT plan based on the upsampled signal, then upsampling can be done by calling the upsample function. For example for a block of signal with shape of (nrows*width) zero padded to (nrows*nfft) where nfft is the next power of 2 for width, then the oversampling of the signal can be done as:</p>
<div class="fragment"><div class="line">sig.forwardRangeFFT(data, spectrum, nfft, nrows);</div>
<div class="line"></div>
<div class="line">sig.inverseRangeFFT(spectrumUpsampled, dataUpsampled, nfft*oversample, nrows);</div>
<div class="line"></div>
<div class="line">sig.upsample(data, dataUpsampled, nrows, nfft, oversample);</div>
</div><!-- fragment --><p>In case if shifting the upsampled signal in time-domain by a constant is desired, one can calculate the liner phase ramp in frequency domain introduced by the constant shift and pass this shift imapct as an extra argument to upsample function directly</p>
<div class="fragment"><div class="line">sig.upsample(data, dataUpsampled, nrows, nfft, oversample, shiftImpact);</div>
</div><!-- fragment --><h1><a class="anchor" id="example1"></a>
Example 1: forward and inverse FFT transformation in range direction</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;isce/signal/Signal.h&quot;</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"></div>
<div class="line">    \\ number of columns in the signal</div>
<div class="line">    <span class="keywordtype">int</span> width = 100;</div>
<div class="line"></div>
<div class="line">    \\ number of rows in the signal</div>
<div class="line">    <span class="keywordtype">int</span> length = 1;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// fft length for FFT computations</span></div>
<div class="line">    <span class="keywordtype">size_t</span> nfft;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// instantiate a signal object</span></div>
<div class="line">    isce::signal::Signal&lt;double&gt; sig;</div>
<div class="line"></div>
<div class="line">    <span class="comment">//compute FFT length     </span></div>
<div class="line">    sig.nextPowerOfTwo(width, nfft);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// reserve memory for a block of data with the size of nfft</span></div>
<div class="line">    std::valarray&lt;std::complex&lt;double&gt;&gt; data(nfft);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// buffer for the spectrum</span></div>
<div class="line">    std::valarray&lt;std::complex&lt;double&gt;&gt; spec(nfft);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// buffer for data after inverse transformation</span></div>
<div class="line">    std::valarray&lt;std::complex&lt;double&gt;&gt; dataInv(nfft);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// fill in the data </span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;width; ++i){</div>
<div class="line">        <span class="keywordtype">double</span> phase = std::sin(10*M_PI*i/width);</div>
<div class="line">        data[i] = std::complex&lt;double&gt; (std::cos(phase), std::sin(phase));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// create the forward and backward plans</span></div>
<div class="line">    sig.forwardRangeFFT(data, spec, nfft, length);</div>
<div class="line">    sig.inverseRangeFFT(spec, dataInv, nfft, length);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// forward transforming the data. Result will be in spec</span></div>
<div class="line">    sig.forward(data, spec);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// backward transformation of spec. Result will be dataInv. </span></div>
<div class="line">    sig.inverse(spec, dataInv);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// normalize dataInv by length of fft. After this normalization, dataInv should be comparable with original data. </span></div>
<div class="line">    dataInv /=nfft; </div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>For more examples see isce::signal::Crossmul and also multiple unit tests in isce/tests/lib/isce/signal. </p>
</div></div><!-- contents -->
<hr>
Generated for ISCE3.0 by
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.8.5.
</body>
</html>
